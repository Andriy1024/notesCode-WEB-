
        <center><h1>STL - Стандартна бібліотека шаблонів</h1></center>
        <br>
        <p>Стандартна бібліотека шаблонів (англ. Standard Template Library; STL) — бібліотека для C++, що містить набір узгоджених узагальнених алгоритмів, контейнерів, засобів доступу до їхнього вмісту і різних допоміжних функцій.</p>
        <p>Стандартна бібліотека шаблонів до включення в стандарт C++ була сторонньою розробкою, на початку — фірми HP, а потім SGI. Стандарт мови не називає її «STL», оскільки ця бібліотека стала невід'ємною частиною мови, проте багато людей досі використовують цю назву, щоб відрізняти її від решти частини стандартної бібліотеки (потоки вводу/виводу (iostream), підрозділ Сі тощо).</p>
        <p>Проект під назвою STLPort, заснований на SGI STL, здійснює постійне оновлення STL, IOstream і рядкових класів. Деякі інші проекти також займаються розробкою приватних застосувань стандартної бібліотеки для різних конструкторських завдань. Кожен виробник компіляторів C++ обов'язково поставляє яку-небудь реалізацію цієї бібліотеки, оскільки вона є дуже важливою частиною стандарту і широко використовується.</p>
        <h2>Структура бібліотеки</h2>
        <p>У бібліотеці виділяють чотири основнi компоненти:</p>
        <p>1. Контейнер (container) — зберігання набору об'єктів в пам'яті.</p>
        <p>2. Ітератор (iterator) — забезпечення засобів послідовного доступу до вмісту контейнера.</p>
        <p>3. Алгоритм (algorithm) — визначення обчислювальної процедури.</p>
        <p>4. Функціональний об'єкт (functor) — заховання функції в об'єкті для використання іншими компонентами.</p>
        <p>Розділення дозволяє зменшити кількість компонентів. Наприклад, замість написання окремої функції пошуку елементу для кожного типу контейнера забезпечується єдина версія, яка працює з кожним з них, поки дотримуються основні вимоги.</p>
        <h2>Контейнери</h2>
        <p>Контейнери бібліотеки STL можна розділити на чотири категорії: послідовні, асоціативні, контейнери-адаптери і псевдоконтейнери.</p>
        <p>1. vector - C-подібний динамічний масив довільного доступу з автоматичною зміною розміру при додаванні/видаленні елементу. Додавання-видалення елементу в кінець vector займає амортизоване {\displaystyle O(1)} {\displaystyle O(1)} час, та ж операція на початку або середині vector — {\displaystyle O(n)} {\displaystyle O(n)}. Існує спеціалізація шаблону vector для типу bool, яка вимагає менше пам'яті за рахунок зберігання bool у вигляді бітів.</p>
        <p>2. list - Двозв'язковий список, елементи якого зберігаються в довільних шматках пам'яті, на відміну від контейнера vector, де елементи зберігаються в безперервній області пам'яті. Повільний пошук і доступ за {\displaystyle O(n)} O(n), в будь-якому місці швидка вставка і видалення за {\displaystyle O(1)} {\displaystyle O(1)}.</p>
        <p>3. deque - Схожий на vector, але з можливістю швидкої вставки і видалення елементів на обох кінцях.</p>
        <h2>Асоціативні контейнери</h2>
        <p>1. set - Впорядкована множина унікальних елементів. При вставці/видаленні елементів множини ітератори, що вказують на елементи цієї множини, не стають недійсними. Забезпечує стандартні операції над множиною типу об'єднання, перетину, віднімання. Тип елементів множини повинен реалізовувати оператора порівняння operator< або потрібно надати функцію-компаратор. Реалізований на основі самобалансуючого дерева двійкового пошуку.</p>
        <p>2. multiset -    Те ж що і set, але дозволяє зберігати елементи, що повторюються.</p>
        <p>3. map - Впорядкований асоціативний масив пар елементів, що складаються з ключів і відповідних ним значень. Ключі повинні бути унікальні. Порядок проходження елементів визначається ключами. При цьому тип ключа повинен реалізовувати оператора порівняння operator<, або потрібно надати функцію-компаратор.</p>
        <p>4. multimap - Те ж що і map, але дозволяє зберігати ключі, що повторюються.</p>
        <h2>Контейнери-адаптери</h2>
        <p>1. stack - Стек — контейнер, в якому додавання і видалення елементів здійснюється з одного кінця.</p>
        <p>2. queue - Черга — контейнер, з одного кінця якого можна додавати елементи, а з іншого — виймати.</p>
        <p>3. priority_queue - Черга з пріоритетом, організована так, що найбільший елемент завжди стоїть на першому місці.</p>
        <h2>Псевдоконтейнери</h2>
        <p>1. bitset - Служить для зберігання бітових масок. Схожий на vector<bool> фіксованого розміру. Розмір фіксується тоді, коли оголошується об'єкт bitset. Ітераторів в bitset немає. Оптимізований за розміром пам'яті.
</p>
        <p>2. basic_string - Контейнер, призначений для зберігання і обробки рядків. Зберігає в пам'яті елементи підряд єдиним блоком, що дозволяє швидкий доступ до всієї послідовності.</p>
        <p>3. valarray - Шаблон служить для зберігання числових масивів і оптимізований для досягнення підвищеної обчислювальної продуктивності. В деякій мірі схожий на vector, але в нім відсутня більшість стандартних для контейнерів операцій. Проте, в ньому реалізовані операції, які можна ефективно реалізувати як на векторних процесорах, так і на скалярних процесорах з блоками SIMD.</p>
        <p>У контейнерах для зберігання елементів використовується семантика передачі об'єктів за значенням. Іншими словами, при додаванні контейнер отримує копію елементу, і за запитом на витягання також повертає копію елементу. Присвоєння елементів реалізується за допомогою оператора присвоєння, а їхнє руйнування відбувається з використанням деструктора.</p>
        <h2>Ітератори</h2>
        <p>У бібліотеці STL для доступу до елементів як посередник використовується узагальнена абстракція, що іменується ітератором. Кожен контейнер підтримує «свій» вид ітератора, який є «модернізованим» інтелектуальним вказівником, що «знає» як отримати доступ до елементів конкретного контейнера.</p>
        <p>1. Вхідні</p>
        <p>Підтримувані операції: operator ++, operator *, operator ->, конструктор копії, operator =, operator ==, operator !=</p>
        <p>Примітка: Забезпечують доступ для читання в одному напрямі. Дозволяють виконати присвоєння або копіювання за допомогою оператора присвоювання і конструктора копії.</p>
        <p>2. Вихідні</p>
        <p>Підтримувані операції: operator ++, operator*, конструктор копії </p>
        <p>Примітка: Забезпечують доступ для запису в одному напрямі. Їх не можна порівнювати на рівність.</p>
        <p>3. Однонаправлені</p>
        <p>Підтримувані операції:   operator ++, operator *, operator ->, конструктор копії, конструктор за умовчанням, operator =, operator ==, operator !=</p>
        <p>Примітка: Забезпечують доступ для читання і запису в одному напрямі. Дозволяють виконати присвоєння або копіювання за допомогою оператора присвоєння і конструктора копії. Їх можна порівнювати на рівність.</p>
        <p>4. Двонаправлені</p>
        <p>Підтримувані операції:   operator++, operator--, operator*, operator ->, конструктор копії, конструктор за умовчанням, operator =, operator ==, operator !=</p>
        <p>Примітка: Підтримують усі функції, описані для однонаправлених ітераторів (дивись вище). Крім того, вони дозволяють переходити до попереднього елементу.</p>
        <p>5. Довільного доступу</p>
        <p>Підтримувані операції: operator ++, operator --, operator *, operator ->, конструктор копії, конструктор за умовчанням, operator =, operator ==, operator !=, operator +, operator -, operator =, operator -=, operator &lt;, operator >, operator &lt;=, operator >=, operator []</p>
        <p>Примітка: Еквівалентні звичайним вказівникам: підтримують арифметику вказівників, синтаксис індексації масивів і усі форми порівняння.</p>
        
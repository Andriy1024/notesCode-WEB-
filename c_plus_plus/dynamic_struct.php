
        <center><h1>Динамічні структури даних</h1></center>
        <br>
        <center><h1>Однозв'язаний список</h1></center>
        <p>Однозв'язний список — вид зв'язаного списку, який складається з вузлів, кожен з яких містить у собі данні (інформаційну частину) та посилання на наступний вузол.</p>
        <p>Найчастіше вузлом списку вважають структурний тип (структуру), який зберігає у собі певну інформаційну частину (іншу структуру або тип даних) та посилання (вказівник) на наступний вузол у списку. Список має «голову» head, тобто вказівник на початок списку та інколи має кінець tail, проте найчастіше його не використовують.</p>
        <h2>Переваги списків над масивами:</h2>
        <p>1. Можливість додавати вузол у кінець списку. Масив має статичний розмір, і, якщо, вільного місця там немає, доведеться створювати масив більшого розміру, копіювати у нього елементи «старого» масиву і тільки після цього додавати новий елемент</p>
        <p>2. Можливість видаляти вузол і звільнювати пам'ять, яку він займав. У масиві можна лише зсунути елементи і розглядати його, як масив меншого розміру. Пам'ять при цьому не звільняється.</p>
        <p>3. Можливість вставляти вузол у середину списку. При умові, що масив не заповнений до кінця, можна «розсунути» елементи і вставити між ними необхідний. Якщо ж масив повний — доведеться створювати новий масив більшого розміру, копіювати елементи і вставляти новий.</p>
        <h2>Недоліки списків перед масивами:</h2>
        <p>1. Відсутність поіндексного доступу до елементів списку</p>
        <p>2. Зайвий час на прохід по списку для пошуку/видалення/додавання елементу у кінець</p>
        <p>3. Використання більшого об'єму пам'яті за рахунок покажчиків на наступний вузол</p>
        <h2>Операції зі списками: </h2>
        <h2>Додати вузол у кінець списку</h2>
        <p>Для того, щоб додати вузол А у кінець списку, треба знайти останній вузол В у цьому списку, заповнити інформаційну частину вузла А і вказівнику вузла А присвоїти NULL, і «приєднати» його до останнього вузла у списку, тобто до вузла В.</p>
        <h2>Додати вузол у початок списку</h2>
        <p>Для того, щоб додати вузол А у початок списку, потрібно заповнити інформаційну частину вузла А, вказівник А направити на голову head списку і зробити цей вузол головою.</p>
        <h2>Видалити заданний вузол зі списку</h2>
        <p>Для того, щоб видалити необхідний вузол, потрібно послідовно перебирати вузли, запам'ятовуючи попередній вузол В. Коли необхідний вузол А буде знайдено, потрібно вказівник «попередника» (тобто вузла В) зв'язати з наступним вузлом (тим, що йде після вузла А) і видалити вузол А.</p>
        <h2>Реалізація списку у С++</h2>
        <pre><code class="cpp">
        struct Node

        {

        int value; // певна інформативна частина

        Node * next; // вказівник (pointer) на наступну структуру-вузол у списку

        };

        Node * head = NULL; // вказівник на голову списку, спочатку він нікуди не вказує, бо список порожній
        </code></pre>
        <h2>Реалізація функції додавання у кінець списку</h2>
        <pre><code class="cpp">void addToEnd(int v)
        {
            Node * n;
            if (!head)
            {
                head = new Node;

                head->value = v;

                head->next = NULL;

                return;
            }
            else
            {
                n = head;

                while (n->next)

                    n = n->next;

             Node * newNode = new Node;

             newNode->value = v;

             newNode->next = NULL;

             n->next = newNode;

             return;

            }
        }</code></pre>
        <h2>Реалізація функції додавання у початок списку</h2>
        <pre><code class="cpp">void addToBegin(int v)
        {
            Node * n = new Node;

            n->value = v;

            n->next = head;

            head = n;
        }</code></pre>
        <h2>Реалізація функції видалення певного вузла</h2>
        <pre><code class="cpp">void deleteNode(Node * n)
        {
            Node * k = head;
            if (head == n)
            {
                 head = n->next;

                delete n;

               return;
            }
             while (k->next != n)

            k = k->next;

            k->next = n->next;

            delete n;
        }</code></pre>
        <h2>Реалізація функції пошуку вузла за інформаційною частиною</h2>
        <pre><code class="cpp">Node * find(const int v)
        {
            Node * n = head;

            while (n)
        {
        if (n->value == v)
            return n;

        n = n->next;
        }
        return NULL;
        }</code></pre>
        <br>
        <center><h1>Стек</h1></center>
        <p>Стек (англ. stack — «стос, стіс») в інформатиці та програмуванні — різновид лінійного списку, структура даних, яка працює за принципом (дисципліною) «останнім прийшов — першим пішов» (LIFO, англ. last in, first out). Всі операції (наприклад, видалення елементу) в стеку можна проводити тільки з одним елементом, який знаходиться на верхівці стеку та був введений в стек останнім.</p>
        <p>Стек можна розглядати як певну аналогію до стопки тарілок, з якої можна взяти верхню, і на яку можна покласти верхню тарілку (інша назва стеку — «магазин», за аналогією з принципом роботи магазину в автоматичній зброї).</p>
        <h2>Операції зі стеком</h2>
        <p>push - («заштовхнути елемент»): елемент додається в стек та розміщується в його верхівці. Розмір стеку збільшується на одиницю. При перевищенні розміру стека граничної величини, відбувається переповнення стека (англ. stack overflow).</p>
        <p>pop - («виштовхнути елемент»): отримує елемент з верхівки стеку. При цьому він видаляється зі стеку і його місце в верхівці стеку займає наступний за ним відповідно до правила LIFO, а розмір стеку зменшується на одиницю. При намаганні «виштовхнути» елемент з вже пустого стеку, відбувається ситуація «незаповнення» стеку (англ. stack underflow).</p>
        <p>Кожна з цих операцій зі стеком виконується за фіксований час O(1) і не залежить від розміру стеку.</p>
        <p>Додаткові операції (присутні не у всіх реалізаціях стеку):</p>
        <p>isEmpty: перевірка наявності елементів в стеку; результат: істина (true), коли стек порожній.</p>
        <p>isFull: перевірка заповненості стека. Результат: істина, коли додавання нового елементу неможливе.</p>
        <p>clear: звільнити стек (видалити усі елементи).</p>
        <p>top: отримати верхній елемент (без виштовхування).</p>
        <p>size: отримати розмір (кількість елементів) стека.</p>
        <h2>Організація в пам'яті комп'ютера</h2>
        <p>Стек може бути організований як масив або множина комірок в певній області комп'ютера з додатковим зберіганням ще й вказівника на верхівку стека. Заштовхування першого елемента в стек збільшує адресу вказівника, виштовхування елементу зменшує її. Таким чином, адреса вказівника завжди відповідає комірці масиву, в якій зараз знаходиться верхівка стеку.</p>
        <p>Багато процесорів ЕОМ мають спеціалізовані регістри, які використовуються як вказівники на верхівку стеку, або використовують деякі з регістрів загального вжитку для цієї спеціальної функції в певних режимах адресації пам'яті.</p>
        <h2>Реалізація стеку у С++</h2>
        <pre><code class="cpp">struct Stek
        {
            int key;

            Stek *next;

        };</code></pre>
        <h2>Реалізація функції push</h2>
        <pre><code class="cpp">void push(Stek **next, int d)
        {
            Stek *pv = new Stek;

            pv->key = d;

            pv->next = *next;

            *next = pv;
        }</code></pre>
        <h2>Реалізація функції pop</h2>
        <pre><code class="cpp">int pop(Stek **next)
        {
            int temp = (*next)->key;

            Stek *pv = (*next);

            (*next) = (*next)->next;

            delete pv;

            return temp;
        }</code></pre>
        <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
       
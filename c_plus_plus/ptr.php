
        <center><h1>Вказівники</h1></center>
        <br>
        <p>Вказівник - змінна, значенням якої є адреса комірки пам'яті. Тобто покажчик посилається на блок даних з області пам'яті, причому на саме його початок. Покажчик може посилатися на змінну або функцію. Для цього потрібно знати адресу змінної або функції. Так ось, щоб дізнатися адресу конкретної змінної в С++ існує унарна операція взяття адреси &. Така операція витягує адреса оголошених змінних, для того, щоб його привласнити покажчику.</p>
        <p>Покажчики використовуються для передачі за посиланням даних, що набагато прискорює процес обробки цих даних (в тому випадку, якщо обсяг даних великий), так як їх не треба копіювати, як при передачі за значенням, тобто, використовуючи ім'я змінної. Зазвичай покажчики використовуються для організації динамічного розподілу пам'яті, наприклад при оголошенні масиву, не треба буде його обмежувати в розмірі. Адже програміст заздалегідь не може знати, якого розміру потрібен масив того чи іншого користувачеві, в такому випадку використовується динамічне виділення пам'яті під масив. Будь покажчик необхідно оголосити перед використанням, як і будь-яку змінну.</p>
        <pre><code class="cpp">
        Тип* імя

        int* a;
        </code></pre>
        <p>Принцип оголошення покажчиків такий же, як і принцип оголошення змінних. Відмінність полягає лише в тому, що перед ім'ям ставиться символ зірочки *. Візуально покажчики відрізняються від змінних тільки одним символом. При оголошенні покажчиків компілятор виділяє кілька байт пам'яті, в залежності від типу даних відводяться для зберігання деякої інформації в пам'яті. Щоб отримати значення, записане в деякій області, на яке посилається покажчик потрібно скористатися операцією разименованія покажчика *. Необхідно поставити зірочку перед ім'ям і отримаємо доступ до значення покажчика.</p>
        <pre><code class="cpp">
        int var = 123;

        // вказівник на var (присвоєння адреси var вказівнику)

        int *ptrvar = &var;

        // адреса var міститься в памяті, витягнутий операцією взяття адреси (&)

        cout << "&var = " << &var << endl;//0x22ff08

        // адрес змінної var, являється значенням вказівника ptrvar

        cout << "ptrvar = " << ptrvar << endl;//0x22ff08

        // значення в змінній var

        cout << "var = " << var << endl;//123

        // вывод значения содержащегося в переменной var через указатель, операцией разименования указателя

        cout << "*ptrvar = " << *ptrvar << endl;//123
        </code></pre>
        <h2>Покажчики на покажчики</h2>
        <p>Покажчики можуть посилатися на інші покажчики. При цьому в комірках пам'яті, на які будуть посилатися перші покажчики, будуть міститися не значення, а адреси других покажчиків. Число символів * при оголошенні покажчика показує порядок покажчика. Щоб отримати доступ до значення, на яке посилається покажчик його необхідно разіменувати відповідну кількість разів. Розробимо програму, яка буде виконувати деякі операції з покажчиками порядку вище першого.</p>
        <pre><code class="cpp">
        int var = 123;

        int *ptrvar = &var;

        int **ptr_ptrvar = &ptrvar; // вказівник на вказівник на змінну var
        </code></pre>
        <h2>Покажчики на функції</h2>
        <p>Покажчики можуть посилатися на функції. Ім'я функції, як і ім'я масиву саме по собі є покажчиком, тобто містить адресу входу.</p>
        <pre><code class="cpp">
        // оголошення вказівника на функцію

        /*тип даних*/ (* /*імя вказівника*/)(/*список аргументів функції*/);
        </code></pre>
        <p>Тип даних визначаємо такий, який буде повертати функція, на яку буде посилатися покажчик. Символ покажчика і його ім'я беруться в круглі скобочки, щоб показати, що це покажчик, а не функція, повертає покажчик на певний тип даних. Після імені покажчика йдуть круглі дужки, в цих дужках перераховуються всі аргументи через кому як в оголошенні прототипу функції. Аргументи успадковуються від тієї функції, на яку буде посилатися покажчик. Розробимо програму, яка використовує покажчик на функцію. Програма повинна знаходити НСД - найбільший спільний дільник. НОД - це найбільше ціле число, на яке без залишку діляться два числа, введених користувачем. Вхідні числа також повинні бути цілими.</p>
        <pre><code class="cpp">
        // прототип функції

        int nod(int, int );

        // оголошуєм вказівник на функцію

        int (*ptrnod)(int, int);

        // присвоюєм адресу функції вказівнику

        ptrnod=nod;

        int a = 24, b =57;

        // звернення до функції через вказівник
        
        cout << "NOD = " << ptrnod(a, b) << endl;
        </code></pre>
        <br>
        <center><h1>Силки</h1></center>
        <br>
        <p>Посилання - особливий тип даних, що є прихованою формою покажчика, який при використанні автоматично розіменовується. Посилання може бути оголошена як іншим ім'ям, або як псевдонім змінної, на яку посилається.</p>
        <pre><code class="cpp">
        // структура обявлення силок

        /*тип*/ &/*імя силки*/ = /*імя змінної*/;
        </code></pre>
        <p>При оголошенні посилання перед її ім'ям ставиться символ амперсанда &, саме ж посилання повинне бути проініціалізоване ім'ям змінної, на яку воно посилається. Тип даних, на який вказує посилання, може бути будь-яким, але повинен збігатися з об'єктом, на який посилається, тобто з типом даних посилальної змінної. Для зручності, будемо називати змінну, на яку посилається посилання «посилальна змінна». Будь-яка зміна значення силки  спричинить за собою змінну значення змінної, на яку посилається посилання. Розробимо програму, в якій оголосимо посилання на об'єкт типу int.</p>
        <pre><code class="cpp">
        int value = 15;

        // оголошення та ініціалізація силки значенням змінної value

        int &reference = value;

        cout << "value = " << value << endl;

        cout << "reference = " << reference << endl;

        // міняєм значення змінної value за допомогою зміни значення в посиланні

        reference+=15;

        // дивимся яке буде значення в змінні

        cout << "value = " << value << endl; //буде 30

        // так і в самому помиланні

        cout << "reference = " << reference << endl; //буде 30
        </code></pre>
        <p>Посилання, як правило, в більшості випадків використовують у функціях як посилання-параметри або посилання-аргументи.</p>
        <pre><code class="cpp">
        // функція яка приймає значення по силці

        int name(const int &reference){}

        // const не дає міняти передаваємий аргумент всередині функциї
        </code></pre>
        <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
       
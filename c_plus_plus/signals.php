
        <center><h1>Сигнали и слоти</h1></center>
        <br>
        <p>При програмуванні графічного інтерфейсу користувача ми часто хотіли б повідомити одну елементи про зміну інших елементів керування. Більш загальним можна сказати, що ми хочемо забезпечити зв'язок між об'єктами будь-яких видів. Наприклад, якщо користувач натискає кнопку Закрити ми, швидше за все, хотім, щоб була викликана функція вікна close ().</p>
        <p>Більш старі інструментарії забезпечують подібний зв'язок за допомогою функцій зворотного виклику. Як передзвонити - це покажчик на функцію. Якщо ви хочете, щоб функція обробки повідомила вас про деяке подію, ви передаєте їй покажчик на іншу функцію (відгук). Функція обробки викличе функцію зворотного виклику, коли це буде доречно. Але даний підхід має два фундаментальних недоліки: по-перше, він не тіпобезопасен. Ми колись не зможемо перевірити, що функція обробки викликає відгук з правильними аргументами. По-друге, цей метод жорстко пов'язаний з функцією обробки, так як вона повинна знати, який відгук викликати.</p>
        <p>В Qt ми ввели техніку, альтернативну функцій зворотного виклику: ми використовуємо сигнали і слоти. Сигнал випускається, коли відбувається певна подія. Віджети Qt мають безліч зумовлених сигналів, і ви завжди можете створити їх підкласи, щоб додати свої сигнали. Слот - це функція, що викликається у відповідь на певний сигнал. Віджети Qt мають безліч зумовлених слотів, але ви, і це стало общеіспользуемих практикою, можете створювати підкласи віджетів і додавати свої слоти для того, щоб обробляти сигнали, як того хочете.</p>
        <br><img src="images/signal.png"><br>
        <p>Цей механізм тіпобезопасен: сигнатура сигналу повинна відповідати сигнатурі приймає слота. (Фактично, слот може мати більш коротку сигнатуру, ніж сигнал, який він отримує, оскільки може ігнорувати зайві аргументи.) Сигнали та слоти пов'язані не жорстко: Клас, що випускає сигнали, не знає і не цікавиться, який з слотів отримає сигнал. Механізм сигналів і слотів Qt гарантує, що, якщо Ви з'єднали сигнал зі слотом, слот буде викликатися з параметрами сигналу в потрібний момент. Сигнали і слоти можуть мати будь-яку кількість аргументів будь-яких типів. Вони повністю типобезпечні.</p>
        <p>Всі класи, успадковані від QObject або одного з його підкласів (наприклад, QWidget) можуть містити сигнали і слоти. Сигнали випускаються при зміні об'єктом свого стану, якщо ця зміна може бути цікаво іншим об'єктам. Всі об'єкти роблять це для зв'язку з іншими об'єктами. Їх не турбує, чи отримує хтось випускаються ними сигнали. Це є істинною инкапсуляцией інформації, і вона гарантує, що об'єкти можуть використовуватися як окремі компоненти програмного забезпечення.</p>
        <p>Слоти можуть отримувати сигнал, але вони також є звичайними функціями-членами. Також, як об'єкт не знає, чи отримує хтось сигнали, що випускаються їм, слоти не знають, чи існують сигнали, з ними пов'язані. Це гарантує, що можна створити повністю незалежні Qt компоненти.</p>
        <p>Ви можете приєднувати до одного слоту стільки сигналів, скільки вам буде потрібно, і один сигнал може бути з'єднаний зі стількома слотами, скільки вам потрібно. Навіть можливо з'єднувати сигнал безпосередньо з іншим сигналом. (Другий сигнал буде випускатися негайно щоразу, коли випускається перший.)</p>
        <p>Разом сигнали і слоти є потужний механізм компонентного програмування.</p>
        <h2>Невеликий приклад</h2>
        <p>Мінімальна декларація класу C ++ може виглядати наступним чином:</p>
        <pre><code class="cpp">class Counter   

        {   

        public:   

        Counter() { m_value = 0; }   

        int value() const { return m_value; }   

        void setValue(int value);   

        private:   

        int m_value;   

        };  </code></pre>
        <p>Невеликий клас, заснований на QObject, може виглядати так:</p>
        <pre><code class="cpp">  #include <QObject>   

        class Counter : public QObject   

        {   

        Q_OBJECT   

        public:   

        Counter() { m_value = 0; }   

        int value() const { return m_value; }   

        public slots:   

        void setValue(int value);   

        signals:   

        void valueChanged(int newValue);   

        private:   

        int m_value;   

        };   </code></pre>
        <p>Версія класу, заснована на QObject, має те ж саме внутрішній стан і надає відкриті методи для доступу до нього, але на додаток до цього вона підтримує компонентне програмування з використанням сигналів і слотів. Цей клас, випустивши сигнал valueChanged (), може повідомляти зовні, що його стан змінилося, і має слот, якому інші об'єкти можуть посилати сигнали.</p>
        <p>Всі класи, що містять сигнали і слоти, повинні згадати макрос Q_OBJECT на початку своєї декларації. Також вони повинні відбуватися (прямо чи опосередковано) від QObject.</p>
        <p>Слоти реалізуються програмістом. Ось можлива реалізація слота Counter :: setValue ():</p>
        <pre><code class="cpp">  void Counter::setValue(int value)   

        {   

        if (value != m_value) {   

         m_value = value;   

        emit valueChanged(value);   

        }   

        }   </code></pre>
        <p>Рядок, що містить emit, змушує об'єкт випустити сигнал valueChanged () з новим значенням, переданим в аргументі.</p>
        <p>У наступному фрагменті коду ми створюємо два об'єкти Counter і з'єднуємо сигнал першого об'єкта valueChanged () зі слотом другого об'єкта setValue (), використовуючи QObject :: connect ():</p>
        <pre><code class="cpp"> Counter a, b;   

       QObject::connect(&a, SIGNAL(valueChanged(int)), &b, SLOT(setValue(int)));   

       // a.value() == 12, b.value() == 12   

       b.setValue(48); // a.value() == 12, b.value() == 48   </code></pre>
        <p>Виклик a.setValue (12) змушує a випускати сигнал valueChanged (12), який буде отриманий об'єктом b через слот setValue (), тобто буде викликана функція b.setValue (12). Потім b сам випустить сигнал valueChanged (), але так як ніхто не пов'язаний з об'єктом b через сигнал valueChanged (), він буде проігнорований.</p>
        <p>Зверніть увагу на те, що функція setValue () встановлює значення і випускається тільки в тому випадку, якщо value! = M_value. Це запобігає нескінченний цикл при циклічних з'єднаннях (наприклад, якби b.valueChanged () був з'єднаний з a.setValue ()).</p>
        <p>Сигнал випускається для кожного з'єднання, яке було створено; якщо сигнал з'єднаний з двома слотами, то він буде виданий двічі. Також ви можете розірвати з'єднання за допомогою QObject :: disconnect ().</p>
        <p>Даний приклад ілюструє спільну роботу об'єктів, які нічого не знають один про одного. Для її досягнення об'єкти повинні бути з'єднані за допомогою виклику простий функції QObject :: connect () або за допомогою функції uic'а - автоматичним зв'язуванням.</p>
        <h2>Сигнали</h2>
        <p>Сигнали випускаються об'єктом, коли змінюється його внутрішній стан, і якщо це може бути цікаво його клієнтам або власнику. Тільки класи, що містять визначення сигналів, і їх підкласи можуть випускати сигнали.</p>
        <p>При випущенні сигналу слоти, з ним пов'язані, виконуються негайно, так само, як при звичайному виконанні функції. Коли це трапляється, механізм сигналів та слотів повністю незалежний від циклу обробки подій графічного інтерфейсу користувача. Виконання коду, наступного за виразом emit продовжиться, як тільки завершиться виконання всіх слотів. У випадку з чергами з'єднань ситуація дещо відмінна; при цьому виконання коду, наступного за emit, продовжиться негайно, а слоти будуть виконані дещо пізніше.</p>
        <p>Якщо кілька слотів пов'язані з одним сигналом, то при випущенні сигналу вони будуть виконані один за іншим в довільному порядку.</p>
        <p>Сигнали автоматично генеруються утилітою moc, і ви не повинні включати їх реалізацію в .cpp файли. Вони не повинні мати повертаються типів (тобто використовувати void).</p>
        <p>Зауваження про аргументи: наш досвід показує, що сигнали і слоти більш придатні для повторного застосування, якщо вони не використовують спеціальних типів. Якщо сигнал QScrollBar :: valueChanged () повинен використовувати спеціальний тип, такий як гіпотетичний QScrollBar :: Range, він може бути з'єднаний лише з слотами, спроектованими спеціально для QScrollBar. З'єднання різних вхідних віджетів разом неможливо.</p>
        <h2>Слоти</h2>
        <p>Слот викликається як тільки випускається з'єднаний з ним сигнал. Слоти - це звичайні функції C ++, вони можуть викликатися звичайним чином; їх єдина особливість - це те, що до них можуть бути приєднані сигнали.</p>
        <p>Так як слоти є звичайними функціями-членами, вони мають права доступу, подібні звичайних функцій-членам. Разом з тим, як слотів вони можуть бути викликані будь-яким компонентом незалежно від рівня доступу за допомогою з'єднання сигнал-слот. Це означає, що сигнал, що випускається об'єктом свавільного класу, може бути пов'язаний з закритим (private) слотом і бути викликаний в зовсім стороннє класі.</p>
        <p>Ви також можете визначати віртуальні слоти, що ми знаходимо дуже корисним на практиці.</p>
        <p>У порівнянні із зворотними викликами, сигнали і слоти трохи повільніше в зв'язку з більшою гнучкістю, яку вони надають, але для реальних додатків ця різниця несуттєво. Взагалі, випускання сигналу, пов'язаного з деякими слотами, приблизно в десять разів повільніше, ніж виклик невіртуальної функції приймача безпосередньо. Так відбувається, тому що потрібно безпечно перебрати всі з'єднання (тобто перевірити, щоб наступні приймачі були зруйновані під час випускання сигналу) і передати параметри покладеним чином. Хоча "десять викликів невіртуальних функцій" здається довгим, це менше ніж, наприклад, операція new або delete. Якщо ви обробляєте рядок, вектор або список, тобто операції, які вимагають виклику new або delete, обробка сигналів і слотів стають не найактивнішими споживачами часу.</p>
        <p>Те ж саме відбувається, коли система викликає слот або побічно викликаються більше десятка функцій. На i586-500 ви можете генерувати близько 2,000,000 сигналів, пов'язаних з одним слотом, в секунду, або близько 1,200,000 сигналів, пов'язаних з двома слотами, в секунду. Простий і гнучкий механізм сигналів та слотів є хорошою оболонкою для внутрішньої реалізації, яку користувачі навіть не будуть помічати.</p>
        <p>Зверніть увагу на те, що інші бібліотеки, що визначають змінні з ім'ям signals або slots, можуть викликати попередження і помилки при компіляції з додатком, створеним на основі Qt. Вирішити цю проблему може директива препроцесора #undef.</p>
        <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
        